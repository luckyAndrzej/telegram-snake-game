# Аудит пользовательских шагов

## Цель: Проверить логику игры, синхронизацию и распределение призов

### Текущее состояние (БЕЗ оплаты, для тестирования):
- ✅ Оплата отключена (`paid: True` сразу)
- ✅ Система тиков реализована (каждые 500ms)
- ✅ Очередь команд (последняя команда за тик)
- ✅ Защита от старых команд (>2 секунд)
- ✅ tick_number для синхронизации клиентов

---

## Пользовательский путь (2 игрока)

### Шаг 1: Игрок 1 нажимает "Играть"
**API:** `POST /api/game/start`
**Действия:**
1. Игрок 1 НЕ в игре → проверяем `waiting_players`
2. Других игроков нет → добавляем игрока 1 в `waiting_players` с `paid: True`
3. **Ответ:** `{status: 'waiting_opponent', paid: True, message: 'Ожидание второго игрока'}`

**Ожидаемое поведение клиента:**
- Показать экран "Ожидание второго игрока"
- Начать polling `/api/game/status` каждые 1-2 секунды

---

### Шаг 2: Игрок 2 нажимает "Играть"
**API:** `POST /api/game/start`
**Действия:**
1. Игрок 2 НЕ в игре → проверяем `waiting_players`
2. Находим игрока 1 в `waiting_players` → `other_waiting = [player1_id]`
3. Добавляем игрока 2 в `waiting_players` с `paid: True`
4. Вызываем `create_game_match(player1_id, player2_id)`:
   - Создается `Game(player1_id, player2_id)`
   - `game_id` добавляется в `active_games`
   - Оба игрока добавляются в `player_to_game`
   - Оба игрока удаляются из `waiting_players`
   - `game.is_running = False` (еще не началась)
5. **Ответ игроку 2:** `{status: 'ready_to_start', game_starting: True, countdown: 5, ...}`

**Ожидаемое поведение клиента (игрок 2):**
- Получить `status: 'ready_to_start'`
- Показать countdown (5...4...3...2...1...GO!)
- После countdown вызвать `/api/game/start-play` для запуска игры

---

### Шаг 3: Игрок 1 проверяет статус (polling)
**API:** `POST /api/game/status`
**Действия:**
1. Игрок 1 в `player_to_game` → получаем `game_id`
2. Игра создана, но `is_running = False` → возвращаем `status: 'ready_to_start'`
3. **Ответ:** `{status: 'ready_to_start', game_starting: True, countdown: 5, ...}`

**Ожидаемое поведение клиента (игрок 1):**
- Получить `status: 'ready_to_start'` (обновление через polling)
- Показать countdown (5...4...3...2...1...GO!)
- После countdown вызвать `/api/game/start-play` для запуска игры

---

### Шаг 4: После countdown оба игрока вызывают `/api/game/start-play`
**API:** `POST /api/game/start-play`
**Действия:**
1. Проверяем `user_id in player_to_game` → получаем `game_id`
2. Проверяем `game_id in active_games` → получаем `game`
3. Если `not game.is_running and not game.is_finished`:
   - Устанавливаем `game.is_running = True`
   - Устанавливаем `game.game_start_timestamp = time.time()`
   - Логируем запуск игры
4. **Ответ:** `{success: True, game_running: True, tick_number: 0, ...}`

**Важно:** После установки `game.is_running = True` игровой цикл (`game_tick_loop`) начинает обрабатывать тики этой игры!

---

### Шаг 5: Игровой процесс
**API:** `POST /api/game/direction` (игроки отправляют направления)
**Действия:**
1. Игрок отправляет направление (up/down/left/right)
2. Сервер вызывает `game.queue_direction(user_id, direction, timestamp)`
3. Команда сохраняется в `game.pending_directions[user_id]`
4. **Ответ:** `{success: True, direction_queued: True, tick_number: X, ...}`

**Игровой цикл (game_tick_loop):**
- Каждые 500ms вызывает `game.tick(current_time)`
- `game.tick()`:
  1. Применяет последние направления из `pending_directions`
  2. Вызывает `snake1.move()` и `snake2.move()`
  3. Проверяет коллизии
  4. Увеличивает `tick_number`
  5. Очищает `pending_directions`

**API:** `POST /api/game/state` (клиенты получают состояние)
**Действия:**
1. Клиенты опрашивают `/api/game/state` каждые 200-500ms
2. Сервер возвращает текущее состояние игры:
   - `tick_number` (для игнорирования устаревших обновлений)
   - `my_snake.body`, `opponent_snake.body`
   - `game_finished`, `winner_id`
3. Клиенты обновляют визуализацию на основе `tick_number`

---

### Шаг 6: Окончание игры (столкновение)
**Сервер:** `game.tick()` обнаруживает коллизию
**Действия:**
1. Одна из змеек умирает (`snake.alive = False`)
2. `game.tick()` устанавливает:
   - `game.is_finished = True`
   - `game.is_running = False`
   - `game.winner_id = opponent_id`
3. Игровой цикл перестает обрабатывать эту игру

**API:** `POST /api/game/end` (клиент отправляет окончание игры)
**Действия:**
1. Клиент отправляет `{user_id, winner, headToHeadCollision}`
2. Сервер проверяет `game.prize_paid` (защита от двойной выплаты)
3. Если `game.prize_paid = False`:
   - Вычисляем призы:
     - `winner_amount = total_bank * 0.75` (75% победителю)
     - `owner_amount = total_bank * 0.25` (25% владельцу)
   - Вызываем `crypto_pay.transfer(winner_id, winner_amount)`
   - Вызываем `crypto_pay.transfer(OWNER_ID, owner_amount)`
   - Устанавливаем `game.prize_paid = True`
4. Вызываем `_cleanup_game_state()` для очистки:
   - Удаляем игроков из `player_to_game`
   - Удаляем игру из `active_games`
   - Очищаем `user_games`
5. **Ответ:** `{winner: True/False, prize: amount, ...}`

**Ожидаемое поведение клиента:**
- Показать экран результатов (Победа/Поражение)
- Показать размер приза (если победитель)
- Кнопка "Играть снова" → возврат к Шагу 1

---

## Проблемы и исправления

### Проблема 1: Оба игрока видят "Ожидание второго игрока"
**Причина:** Неправильная логика в `/api/game/start` - проверка `if user_id in waiting_players` выполняется ПЕРЕД проверкой других игроков.

**Исправление:** ✅ Переписана логика - сначала проверяем других ожидающих игроков, потом добавляем текущего.

### Проблема 2: Игра не запускается после countdown
**Причина:** `game.is_running = True` не устанавливается после countdown.

**Исправление:** ✅ Добавлен эндпоинт `/api/game/start-play` который устанавливает `game.is_running = True`.

### Проблема 3: Оплата еще включена в некоторых местах
**Причина:** `api_check_payment` все еще проверяет invoice_id.

**Статус:** ⚠️ Эндпоинт `/api/game/check-payment` используется, но основная логика обходит его (paid: True сразу).

**Рекомендация:** Можно временно отключить или оставить для совместимости.

---

## Проверка синхронизации

### Что должно работать:
1. ✅ Оба игрока видят одинаковое состояние игры (через `tick_number`)
2. ✅ Последняя команда за тик побеждает (race condition защита)
3. ✅ Старые команды (>2 секунд) игнорируются
4. ✅ Игра обновляется строго каждые 500ms (предсказуемость)

### Что нужно проверить:
- [ ] Клиент правильно игнорирует устаревшие обновления (сравнивает `tick_number`)
- [ ] Оба клиента вызывают `/api/game/start-play` после countdown
- [ ] Направления применяются правильно (последняя команда за тик)
- [ ] Коллизии определяются одинаково для обоих игроков

---

## Проверка распределения призов

### Логика выплат (75% победителю, 25% владельцу):
1. Игра завершается → `game.winner_id` устанавливается сервером
2. Первый клиент отправляет `/api/game/end`
3. Сервер проверяет `game.prize_paid`
4. Если `prize_paid = False`:
   - Выплачивает `total_bank * 0.75` победителю
   - Выплачивает `total_bank * 0.25` владельцу
   - Устанавливает `game.prize_paid = True`
5. Последующие запросы `/api/game/end` игнорируют выплаты (защита от дублей)

**Важно:** Для тестирования без оплаты выплаты не будут работать (crypto_pay отключен), но логика должна быть корректной.

---

## Рекомендации для тестирования

1. **Запустить игру с двумя пользователями:**
   - Игрок 1 нажимает "Играть" → должен увидеть "Ожидание второго игрока"
   - Игрок 2 нажимает "Играть" → должна создаться игра, оба видят countdown
   - После countdown оба видят игровое поле
   - Движение должно быть синхронизированным

2. **Проверить синхронизацию:**
   - Оба игрока двигаются → проверить что движения видны обоим
   - Один игрок столкнулся → оба должны увидеть окончание игры
   - Проверить что `tick_number` увеличивается правильно

3. **Проверить логику призов:**
   - После окончания игры проверить логи (должно быть сообщение о выплате)
   - Проверить что `game.prize_paid = True` после выплаты
   - Проверить что повторный запрос `/api/game/end` не создает двойную выплату

---

## Готовность к деплою

### ✅ Готово:
- Система тиков реализована
- Матчмейкинг исправлен
- Защита от двойных выплат
- Очистка состояния игры

### ⚠️ Требует проверки:
- Клиентская часть (app.js) - вызов `/api/game/start-play` после countdown
- Синхронизация через `tick_number` на клиенте
- Обработка устаревших обновлений

### ❌ Отключено (для тестирования):
- Реальная оплата (paid: True сразу)
- Проверка invoice_id в матчмейкинге

**Для включения оплаты:**
- Восстановить проверку `paid: True` в `create_game_match`
- Восстановить создание invoice в `/api/game/start`
- Включить polling `/api/game/check-payment` на клиенте

